"use strict";
const assert_1 = require("@aws-cdk/assert");
const aws_ec2_1 = require("@aws-cdk/aws-ec2");
const core_1 = require("@aws-cdk/core");
const lib_1 = require("../lib");
class FakeTarget {
    constructor() {
        this.connections = new aws_ec2_1.Connections({
            peer: aws_ec2_1.Peer.ipv4('666.666.666.666/666')
        });
    }
    attachToClassicLB(_loadBalancer) {
        // Nothing to do. Normally we set a property on ourselves so
        // our instances know to bind to the LB on startup.
    }
}
module.exports = {
    'test specifying nonstandard port works'(test) {
        const stack = new core_1.Stack(undefined, undefined, { env: { account: '1234', region: 'test' } });
        stack.node.setContext('availability-zones:1234:test', ['test-1a', 'test-1b']);
        const vpc = new aws_ec2_1.Vpc(stack, 'VCP');
        const lb = new lib_1.LoadBalancer(stack, 'LB', { vpc });
        lb.addListener({
            externalProtocol: lib_1.LoadBalancingProtocol.HTTP,
            externalPort: 8080,
            internalProtocol: lib_1.LoadBalancingProtocol.HTTP,
            internalPort: 8080,
        });
        assert_1.expect(stack).to(assert_1.haveResource("AWS::ElasticLoadBalancing::LoadBalancer", {
            Listeners: [{
                    InstancePort: "8080",
                    InstanceProtocol: "http",
                    LoadBalancerPort: "8080",
                    Protocol: "http"
                }]
        }));
        test.done();
    },
    'add a health check'(test) {
        // GIVEN
        const stack = new core_1.Stack();
        const vpc = new aws_ec2_1.Vpc(stack, 'VCP');
        // WHEN
        new lib_1.LoadBalancer(stack, 'LB', {
            vpc,
            healthCheck: {
                interval: core_1.Duration.minutes(1),
                path: '/ping',
                protocol: lib_1.LoadBalancingProtocol.HTTPS,
                port: 443,
            }
        });
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource("AWS::ElasticLoadBalancing::LoadBalancer", {
            HealthCheck: {
                HealthyThreshold: "2",
                Interval: "60",
                Target: "HTTPS:443/ping",
                Timeout: "5",
                UnhealthyThreshold: "5"
            },
        }));
        test.done();
    },
    'add a listener and load balancing target'(test) {
        // GIVEN
        const stack = new core_1.Stack();
        const vpc = new aws_ec2_1.Vpc(stack, 'VCP');
        const elb = new lib_1.LoadBalancer(stack, 'LB', {
            vpc,
            healthCheck: {
                interval: core_1.Duration.minutes(1),
                path: '/ping',
                protocol: lib_1.LoadBalancingProtocol.HTTPS,
                port: 443,
            }
        });
        // WHEN
        elb.addListener({ externalPort: 80, internalPort: 8080 });
        elb.addTarget(new FakeTarget());
        // THEN: at the very least it added a security group rule for the backend
        assert_1.expect(stack).to(assert_1.haveResource('AWS::EC2::SecurityGroup', {
            SecurityGroupEgress: [
                {
                    Description: 'Port 8080 LB to fleet',
                    CidrIp: "666.666.666.666/666",
                    FromPort: 8080,
                    IpProtocol: "tcp",
                    ToPort: 8080
                }
            ],
        }));
        test.done();
    },
    'enable cross zone load balancing'(test) {
        // GIVEN
        const stack = new core_1.Stack();
        const vpc = new aws_ec2_1.Vpc(stack, 'VCP');
        // WHEN
        new lib_1.LoadBalancer(stack, 'LB', {
            vpc,
            crossZone: true,
        });
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource('AWS::ElasticLoadBalancing::LoadBalancer', {
            CrossZone: true
        }));
        test.done();
    },
    'disable cross zone load balancing'(test) {
        // GIVEN
        const stack = new core_1.Stack();
        const vpc = new aws_ec2_1.Vpc(stack, 'VCP');
        // WHEN
        new lib_1.LoadBalancer(stack, 'LB', {
            vpc,
            crossZone: false,
        });
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource('AWS::ElasticLoadBalancing::LoadBalancer', {
            CrossZone: false
        }));
        test.done();
    },
    'cross zone load balancing enabled by default'(test) {
        // GIVEN
        const stack = new core_1.Stack();
        const vpc = new aws_ec2_1.Vpc(stack, 'VCP');
        // WHEN
        new lib_1.LoadBalancer(stack, 'LB', {
            vpc,
        });
        // THEN
        assert_1.expect(stack).to(assert_1.haveResource('AWS::ElasticLoadBalancing::LoadBalancer', {
            CrossZone: true
        }));
        test.done();
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5sb2FkYmFsYW5jZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0ZXN0LmxvYWRiYWxhbmNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsNENBQXVEO0FBQ3ZELDhDQUEwRDtBQUMxRCx3Q0FBZ0Q7QUFFaEQsZ0NBQWtGO0FBdUpsRixNQUFNLFVBQVU7SUFBaEI7UUFDa0IsZ0JBQVcsR0FBRyxJQUFJLHFCQUFXLENBQUM7WUFDNUMsSUFBSSxFQUFFLGNBQUksQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUM7U0FDdkMsQ0FBQyxDQUFDO0lBTUwsQ0FBQztJQUpRLGlCQUFpQixDQUFDLGFBQTJCO1FBQ2xELDREQUE0RDtRQUM1RCxtREFBbUQ7SUFDckQsQ0FBQztDQUNGO0FBOUpELGlCQUFTO0lBQ1Asd0NBQXdDLENBQUMsSUFBVTtRQUNqRCxNQUFNLEtBQUssR0FBRyxJQUFJLFlBQUssQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQUMsQ0FBQyxDQUFDO1FBQzNGLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLDhCQUE4QixFQUFFLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDOUUsTUFBTSxHQUFHLEdBQUcsSUFBSSxhQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRWxDLE1BQU0sRUFBRSxHQUFHLElBQUksa0JBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUVsRCxFQUFFLENBQUMsV0FBVyxDQUFDO1lBQ2IsZ0JBQWdCLEVBQUUsMkJBQXFCLENBQUMsSUFBSTtZQUM1QyxZQUFZLEVBQUUsSUFBSTtZQUNsQixnQkFBZ0IsRUFBRSwyQkFBcUIsQ0FBQyxJQUFJO1lBQzVDLFlBQVksRUFBRSxJQUFJO1NBQ25CLENB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QyxxQkFBWSxDQUFDLHlDQUF5QyxFQUFFO1lBQ3ZFLFNBQVMsRUFBRSxJQUFJO1NBQ2hCLENBQUMsQ0FBQyxDQUFDO1FBRUosSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2QsQ0FBQztDQUVGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleHBlY3QsIGhhdmVSZXNvdXJjZSB9IGZyb20gJ0Bhd3MtY2RrL2Fzc2VydCc7XG5pbXBvcnQgeyBDb25uZWN0aW9ucywgUGVlciwgVnBjIH0gZnJvbSAnQGF3cy1jZGsvYXdzLWVjMic7XG5pbXBvcnQgeyBEdXJhdGlvbiwgU3RhY2sgfSBmcm9tICdAYXdzLWNkay9jb3JlJztcbmltcG9ydCB7IFRlc3QgfSBmcm9tICdub2RldW5pdCc7XG5pbXBvcnQgeyBJTG9hZEJhbGFuY2VyVGFyZ2V0LCBMb2FkQmFsYW5jZXIsIExvYWRCYWxhbmNpbmdQcm90b2NvbCB9IGZyb20gJy4uL2xpYic7XG5cbmV4cG9ydCA9IHtcbiAgJ3Rlc3Qgc3BlY2lmeWluZyBub25zdGFuZGFyZCBwb3J0IHdvcmtzJyh0ZXN0OiBUZXN0KSB7XG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2sodW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgZW52OiB7IGFjY291bnQ6ICcxMjM0JywgcmVnaW9uOiAndGVzdCcgfX0pO1xuICAgIHN0YWNrLm5vZGUuc2V0Q29udGV4dCgnYXZhaWxhYmlsaXR5LXpvbmVzOjEyMzQ6dGVzdCcsIFsndGVzdC0xYScsICd0ZXN0LTFiJ10pO1xuICAgIGNvbnN0IHZwYyA9IG5ldyBWcGMoc3RhY2ssICdWQ1AnKTtcblxuICAgIGNvbnN0IGxiID0gbmV3IExvYWRCYWxhbmNlcihzdGFjaywgJ0xCJywgeyB2cGMgfSk7XG5cbiAgICBsYi5hZGRMaXN0ZW5lcih7XG4gICAgICBleHRlcm5hbFByb3RvY29sOiBMb2FkQmFsYW5jaW5nUHJvdG9jb2wuSFRUUCxcbiAgICAgIGV4dGVybmFsUG9ydDogODA4MCxcbiAgICAgIGludGVybmFsUHJvdG9jb2w6IExvYWRCYWxhbmNpbmdQcm90b2NvbC5IVFRQLFxuICAgICAgaW50ZXJuYWxQb3J0OiA4MDgwLFxuICAgIH0pO1xuXG4gICAgZXhwZWN0KHN0YWNrKS50byhoYXZlUmVzb3VyY2UoXCJBV1M6OkVsYXN0aWNMb2FkQmFsYW5jaW5nOjpMb2FkQmFsYW5jZXJcIiwge1xuICAgICAgTGlzdGVuZXJzOiBbe1xuICAgICAgICBJbnN0YW5jZVBvcnQ6IFwiODA4MFwiLFxuICAgICAgICBJbnN0YW5jZVByb3RvY29sOiBcImh0dHBcIixcbiAgICAgICAgTG9hZEJhbGFuY2VyUG9ydDogXCI4MDgwXCIsXG4gICAgICAgIFByb3RvY29sOiBcImh0dHBcIlxuICAgICAgfV1cbiAgICB9KSk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnYWRkIGEgaGVhbHRoIGNoZWNrJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIGNvbnN0IHZwYyA9IG5ldyBWcGMoc3RhY2ssICdWQ1AnKTtcblxuICAgIC8vIFdIRU5cbiAgICBuZXcgTG9hZEJhbGFuY2VyKHN0YWNrLCAnTEInLCB7XG4gICAgICB2cGMsXG4gICAgICBoZWFsdGhDaGVjazoge1xuICAgICAgICBpbnRlcnZhbDogRHVyYXRpb24ubWludXRlcygxKSxcbiAgICAgICAgcGF0aDogJy9waW5nJyxcbiAgICAgICAgcHJvdG9jb2w6IExvYWRCYWxhbmNpbmdQcm90b2NvbC5IVFRQUyxcbiAgICAgICAgcG9ydDogNDQzLFxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVEhFTlxuICAgIGV4cGVjdChzdGFjaykudG8oaGF2ZVJlc291cmNlKFwiQVdTOjpFbGFzdGljTG9hZEJhbGFuY2luZzo6TG9hZEJhbGFuY2VyXCIsIHtcbiAgICAgIEhlYWx0aENoZWNrOiB7XG4gICAgICAgIEhlYWx0aHlUaHJlc2hvbGQ6IFwiMlwiLFxuICAgICAgICBJbnRlcnZhbDogXCI2MFwiLFxuICAgICAgICBUYXJnZXQ6IFwiSFRUUFM6NDQzL3BpbmdcIixcbiAgICAgICAgVGltZW91dDogXCI1XCIsXG4gICAgICAgIFVuaGVhbHRoeVRocmVzaG9sZDogXCI1XCJcbiAgICAgIH0sXG4gICAgfSkpO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ2FkZCBhIGxpc3RlbmVyIGFuZCBsb2FkIGJhbGFuY2luZyB0YXJnZXQnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgY29uc3QgdnBjID0gbmV3IFZwYyhzdGFjaywgJ1ZDUCcpO1xuICAgIGNvbnN0IGVsYiA9IG5ldyBMb2FkQmFsYW5jZXIoc3RhY2ssICdMQicsIHtcbiAgICAgIHZwYyxcbiAgICAgIGhlYWx0aENoZWNrOiB7XG4gICAgICAgIGludGVydmFsOiBEdXJhdGlvbi5taW51dGVzKDEpLFxuICAgICAgICBwYXRoOiAnL3BpbmcnLFxuICAgICAgICBwcm90b2NvbDogTG9hZEJhbGFuY2luZ1Byb3RvY29sLkhUVFBTLFxuICAgICAgICBwb3J0OiA0NDMsXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBXSEVOXG4gICAgZWxiLmFkZExpc3RlbmVyKHsgZXh0ZXJuYWxQb3J0OiA4MCwgaW50ZXJuYWxQb3J0OiA4MDgwIH0pO1xuICAgIGVsYi5hZGRUYXJnZXQobmV3IEZha2VUYXJnZXQoKSk7XG5cbiAgICAvLyBUSEVOOiBhdCB0aGUgdmVyeSBsZWFzdCBpdCBhZGRlZCBhIHNlY3VyaXR5IGdyb3VwIHJ1bGUgZm9yIHRoZSBiYWNrZW5kXG4gICAgZXhwZWN0KHN0YWNrKS50byhoYXZlUmVzb3VyY2UoJ0FXUzo6RUMyOjpTZWN1cml0eUdyb3VwJywge1xuICAgICAgU2VjdXJpdHlHcm91cEVncmVzczogW1xuICAgICAgICB7XG4gICAgICAgICAgRGVzY3JpcHRpb246ICdQb3J0IDgwODAgTEIgdG8gZmxlZXQnLFxuICAgICAgICAgIENpZHJJcDogXCI2NjYuNjY2LjY2Ni42NjYvNjY2XCIsXG4gICAgICAgICAgRnJvbVBvcnQ6IDgwODAsXG4gICAgICAgICAgSXBQcm90b2NvbDogXCJ0Y3BcIixcbiAgICAgICAgICBUb1BvcnQ6IDgwODBcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICB9KSk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxuICAnZW5hYmxlIGNyb3NzIHpvbmUgbG9hZCBiYWxhbmNpbmcnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgY29uc3QgdnBjID0gbmV3IFZwYyhzdGFjaywgJ1ZDUCcpO1xuXG4gICAgLy8gV0hFTlxuICAgIG5ldyBMb2FkQmFsYW5jZXIoc3RhY2ssICdMQicsIHtcbiAgICAgIHZwYyxcbiAgICAgIGNyb3NzWm9uZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8vIFRIRU5cbiAgICBleHBlY3Qoc3RhY2spLnRvKGhhdmVSZXNvdXJjZSgnQVdTOjpFbGFzdGljTG9hZEJhbGFuY2luZzo6TG9hZEJhbGFuY2VyJywge1xuICAgICAgQ3Jvc3Nab25lOiB0cnVlXG4gICAgfSkpO1xuXG4gICAgdGVzdC5kb25lKCk7XG4gIH0sXG5cbiAgJ2Rpc2FibGUgY3Jvc3Mgem9uZSBsb2FkIGJhbGFuY2luZycodGVzdDogVGVzdCkge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICBjb25zdCB2cGMgPSBuZXcgVnBjKHN0YWNrLCAnVkNQJyk7XG5cbiAgICAvLyBXSEVOXG4gICAgbmV3IExvYWRCYWxhbmNlcihzdGFjaywgJ0xCJywge1xuICAgICAgdnBjLFxuICAgICAgY3Jvc3Nab25lOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIC8vIFRIRU5cbiAgICBleHBlY3Qoc3RhY2spLnRvKGhhdmVSZXNvdXJjZSgnQVdTOjpFbGFzdGljTG9hZEJhbGFuY2luZzo6TG9hZEJhbGFuY2VyJywge1xuICAgICAgQ3Jvc3Nab25lOiBmYWxzZVxuICAgIH0pKTtcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gICdjcm9zcyB6b25lIGxvYWQgYmFsYW5jaW5nIGVuYWJsZWQgYnkgZGVmYXVsdCcodGVzdDogVGVzdCkge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICBjb25zdCB2cGMgPSBuZXcgVnBjKHN0YWNrLCAnVkNQJyk7XG5cbiAgICAvLyBXSEVOXG4gICAgbmV3IExvYWRCYWxhbmNlcihzdGFjaywgJ0xCJywge1xuICAgICAgdnBjLFxuICAgIH0pO1xuXG4gICAgLy8gVEhFTlxuICAgIGV4cGVjdChzdGFjaykudG8oaGF2ZVJlc291cmNlKCdBV1M6OkVsYXN0aWNMb2FkQmFsYW5jaW5nOjpMb2FkQmFsYW5jZXInLCB7XG4gICAgICBDcm9zc1pvbmU6IHRydWVcbiAgICB9KSk7XG5cbiAgICB0ZXN0LmRvbmUoKTtcbiAgfSxcblxufTtcblxuY2xhc3MgRmFrZVRhcmdldCBpbXBsZW1lbnRzIElMb2FkQmFsYW5jZXJUYXJnZXQge1xuICBwdWJsaWMgcmVhZG9ubHkgY29ubmVjdGlvbnMgPSBuZXcgQ29ubmVjdGlvbnMoe1xuICAgIHBlZXI6IFBlZXIuaXB2NCgnNjY2LjY2Ni42NjYuNjY2LzY2NicpXG4gIH0pO1xuXG4gIHB1YmxpYyBhdHRhY2hUb0NsYXNzaWNMQihfbG9hZEJhbGFuY2VyOiBMb2FkQmFsYW5jZXIpOiB2b2lkIHtcbiAgICAvLyBOb3RoaW5nIHRvIGRvLiBOb3JtYWxseSB3ZSBzZXQgYSBwcm9wZXJ0eSBvbiBvdXJzZWx2ZXMgc29cbiAgICAvLyBvdXIgaW5zdGFuY2VzIGtub3cgdG8gYmluZCB0byB0aGUgTEIgb24gc3RhcnR1cC5cbiAgfVxufVxuIl19