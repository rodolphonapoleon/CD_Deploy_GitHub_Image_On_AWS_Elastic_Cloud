"use strict";
const sinon = require("sinon");
const lib_1 = require("../lib");
const docker_1 = require("../lib/docker");
const os = require("../lib/os");
const mock_sdk_1 = require("./util/mock-sdk");
module.exports = {
    async 'creates repository with given name'(test) {
        // GIVEN
        let createdName;
        const sdk = new mock_sdk_1.MockSDK();
        sdk.stubEcr({
            describeRepositories() {
                return { repositories: [] };
            },
            createRepository(req) {
                createdName = req.repositoryName;
                // Stop the test so that we don't actually docker build
                throw new Error('STOPTEST');
            },
        });
        const toolkit = new lib_1.ToolkitInfo({
            sdk,
            bucketName: 'BUCKET_NAME',
            bucketEndpoint: 'BUCKET_ENDPOINT',
            environment: { name: 'env', account: '1234', region: 'abc' }
        });
        // WHEN
        const asset = {
            id: 'assetId',
            imageNameParameter: 'MyParameter',
            packaging: 'container-image',
            path: '/foo',
            repositoryName: 'some-name',
            sourceHash: '0123456789abcdef',
        };
        try {
            await docker_1.prepareContainerAsset('.', asset, toolkit, false);
        }
        catch (e) {
            if (!/STOPTEST/.test(e.toString())) {
                throw e;
            }
        }
        // THEN
        test.deepEqual(createdName, 'some-name');
        test.done();
    },
    async 'passes the correct args to docker build'(test) {
        // GIVEN
        const toolkit = new lib_1.ToolkitInfo({
            sdk: new mock_sdk_1.MockSDK(),
            bucketName: 'BUCKET_NAME',
            bucketEndpoint: 'BUCKET_ENDPOINT',
            environment: { name: 'env', account: '1234', region: 'abc' }
        });
        const prepareEcrRepositoryStub = sinon.stub(toolkit, 'prepareEcrRepository').resolves({
            repositoryUri: 'uri',
            repositoryName: 'name'
        });
        const shellStub = sinon.stub(os, 'shell').rejects('STOPTEST');
        // WHEN
        const asset = {
            id: 'assetId',
            imageNameParameter: 'MyParameter',
            packaging: 'container-image',
            path: '/foo',
            sourceHash: '1234567890abcdef',
            repositoryName: 'some-name',
            buildArgs: {
                a: 'b',
                c: 'd'
            }
        };
        try {
            await docker_1.prepareContainerAsset('.', asset, toolkit, false);
        }
        catch (e) {
            if (!/STOPTEST/.test(e.toString())) {
                throw e;
            }
        }
        // THEN
        const command = ['docker', 'build', '--build-arg', 'a=b', '--build-arg', 'c=d', '--tag', `uri:latest`, '/foo'];
        test.ok(shellStub.calledWith(command));
        prepareEcrRepositoryStub.restore();
        shellStub.restore();
        test.done();
    },
    async 'relative path'(test) {
        // GIVEN
        const toolkit = new lib_1.ToolkitInfo({
            sdk: new mock_sdk_1.MockSDK(),
            bucketName: 'BUCKET_NAME',
            bucketEndpoint: 'BUCKET_ENDPOINT',
            environment: { name: 'env', account: '1234', region: 'abc' }
        });
        const prepareEcrRepositoryStub = sinon.stub(toolkit, 'prepareEcrRepository').resolves({
            repositoryUri: 'uri',
            repositoryName: 'name'
        });
        const shellStub = sinon.stub(os, 'shell').rejects('STOPTEST');
        // WHEN
        const asset = {
            id: 'assetId',
            imageNameParameter: 'MyParameter',
            packaging: 'container-image',
            path: 'relative-to-assembly',
            sourceHash: '1234567890abcdef',
            repositoryName: 'some-name',
            buildArgs: {
                a: 'b',
                c: 'd'
            }
        };
        try {
            await docker_1.prepareContainerAsset('/assembly/dir/root', asset, toolkit, false);
        }
        catch (e) {
            if (!/STOPTEST/.test(e.toString())) {
                throw e;
            }
        }
        // THEN
        const command = ['docker', 'build', '--build-arg', 'a=b', '--build-arg', 'c=d', '--tag', `uri:latest`, '/assembly/dir/root/relative-to-assembly'];
        test.ok(shellStub.calledWith(command));
        prepareEcrRepositoryStub.restore();
        shellStub.restore();
        test.done();
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5kb2NrZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0ZXN0LmRvY2tlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBRUEsK0JBQWdDO0FBQ2hDLGdDQUFxQztBQUNyQywwQ0FBc0Q7QUFDdEQsZ0NBQWlDO0FBQ2pDLDhDQUEwQztBQUUxQyxpQkFBUztJQUNQLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxJQUFVO1FBQ25ELFFBQVE7UUFFUixJQUFJLFdBQVcsQ0FBQztRQUVoQixNQUFNLEdBQUcsR0FBRyxJQUFJLGtCQUFPLEVBQUUsQ0FBQztRQUMxQixHQUFHLENBQUMsT0FBTyxDQUFDO1lBQ1Ysb0JBQW9CO2dCQUNsQixPQUFPLEVBQUUsWUFBWSxFQUFFLEVBQUUsRUFBRSxDQUFDO1lBQzlCLENBQUM7WUFFRCxnQkFBZ0IsQ0FBQyxHQUFHO2dCQUNsQixXQUFXLEdBQUcsR0FBRyxDQUFDLGNBQWMsQ0FBQztnQkFFakMsdURBQXVEO2dCQUN2RCxNQUFNLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzlCLENBQUM7U0FDRixDQUFDLENBQUM7UUFFSCxNQUFNLE9BQU8sR0FBRyxJQUFJLGlCQUFXLENBQUM7WUFDOUIsR0FBRztZQUNILFVBQVUsRUFBRSxhQUFhO1lBQ3pCLGNBQWMsRUFBRSxpQkFBaUI7WUFDakMsV0FBVyxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7U0FDN0QsQ0FBQyxDQUFDO1FBRUgsT0FBTztRQUNQLE1BQU0sS0FBSyxHQUEyQztZQUNwRCxFQUFFLEVBQUUsU0FBUztZQUNiLGtCQUFrQixFQUFFLGFBQWE7WUFDakMsU0FBUyxFQUFFLGlCQUFpQjtZQUM1QixJQUFJLEVBQUUsTUFBTTtZQUNaLGNBQWMsRUFBRSxXQUFXO1lBQzNCLFVBQVUsRUFBRSxrQkFBa0I7U0FDL0IsQ0FBQztRQUVGLElBQUk7WUFDRixNQUFNLDhC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QUFDO0lBQ2QsQ0FBQztDQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3hhcGkgPSByZXF1aXJlKCdAYXdzLWNkay9jeC1hcGknKTtcbmltcG9ydCB7IFRlc3QgfSBmcm9tICdub2RldW5pdCc7XG5pbXBvcnQgc2lub24gPSByZXF1aXJlKCdzaW5vbicpO1xuaW1wb3J0IHsgVG9vbGtpdEluZm8gfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHsgcHJlcGFyZUNvbnRhaW5lckFzc2V0IH0gZnJvbSAnLi4vbGliL2RvY2tlcic7XG5pbXBvcnQgb3MgPSByZXF1aXJlKCcuLi9saWIvb3MnKTtcbmltcG9ydCB7IE1vY2tTREsgfSBmcm9tICcuL3V0aWwvbW9jay1zZGsnO1xuXG5leHBvcnQgPSB7XG4gIGFzeW5jICdjcmVhdGVzIHJlcG9zaXRvcnkgd2l0aCBnaXZlbiBuYW1lJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cblxuICAgIGxldCBjcmVhdGVkTmFtZTtcblxuICAgIGNvbnN0IHNkayA9IG5ldyBNb2NrU0RLKCk7XG4gICAgc2RrLnN0dWJFY3Ioe1xuICAgICAgZGVzY3JpYmVSZXBvc2l0b3JpZXMoKSB7XG4gICAgICAgIHJldHVybiB7IHJlcG9zaXRvcmllczogW10gfTtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZVJlcG9zaXRvcnkocmVxKSB7XG4gICAgICAgIGNyZWF0ZWROYW1lID0gcmVxLnJlcG9zaXRvcnlOYW1lO1xuXG4gICAgICAgIC8vIFN0b3AgdGhlIHRlc3Qgc28gdGhhdCB3ZSBkb24ndCBhY3R1YWxseSBkb2NrZXIgYnVpbGRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTVE9QVEVTVCcpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHRvb2xraXQgPSBuZXcgVG9vbGtpdEluZm8oe1xuICAgICAgc2RrLFxuICAgICAgYnVja2V0TmFtZTogJ0JVQ0tFVF9OQU1FJyxcbiAgICAgIGJ1Y2tldEVuZHBvaW50OiAnQlVDS0VUX0VORFBPSU5UJyxcbiAgICAgIGVudmlyb25tZW50OiB7IG5hbWU6ICdlbnYnLCBhY2NvdW50OiAnMTIzNCcsIHJlZ2lvbjogJ2FiYycgfVxuICAgIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IGFzc2V0OiBjeGFwaS5Db250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSA9IHtcbiAgICAgIGlkOiAnYXNzZXRJZCcsXG4gICAgICBpbWFnZU5hbWVQYXJhbWV0ZXI6ICdNeVBhcmFtZXRlcicsXG4gICAgICBwYWNrYWdpbmc6ICdjb250YWluZXItaW1hZ2UnLFxuICAgICAgcGF0aDogJy9mb28nLFxuICAgICAgcmVwb3NpdG9yeU5hbWU6ICdzb21lLW5hbWUnLFxuICAgICAgc291cmNlSGFzaDogJzAxMjM0NTY3ODlhYmNkZWYnLFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJlcGFyZUNvbnRhaW5lckFzc2V0KCcuJywgYXNzZXQsIHRvb2xraXQsIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIS9TVE9QVEVTVC8udGVzdChlLnRvU3RyaW5nKCkpKSB7IHRocm93IGU7IH1cbiAgICB9XG5cbiAgICAvLyBUSEVOXG4gICAgdGVzdC5kZWVwRXF1YWwoY3JlYXRlZE5hbWUsICdzb21lLW5hbWUnKTtcblxuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gIGFzeW5jICdwYXNzZXMgdGhlIGNvcnJlY3QgYXJncyB0byBkb2NrZXIgYnVpbGQnKHRlc3Q6IFRlc3QpIHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHRvb2xraXQgPSBuZXcgVG9vbGtpdEluZm8oe1xuICAgICAgc2RrOiBuZXcgTW9ja1NESygpLFxuICAgICAgYnVja2V0TmFtZTogJ0JVQ0tFVF9OQU1FJyxcbiAgICAgIGJ1Y2tldEVuZHBvaW50OiAnQlVDS0VUX0VORFBPSU5UJyxcbiAgICAgIGVudmlyb25tZW50OiB7IG5hbWU6ICdlbnYnLCBhY2NvdW50OiAnMTIzNCcsIHJlZ2lvbjogJ2FiYycgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcHJlcGFyZUVjclJlcG9zaXRvcnlTdHViID0gc2lub24uc3R1Yih0b29sa2l0LCAncHJlcGFyZUVjclJlcG9zaXRvcnknKS5yZXNvbHZlcyh7XG4gICAgICByZXBvc2l0b3J5VXJpOiAndXJpJyxcbiAgICAgIHJlcG9zaXRvcnlOYW1lOiAnbmFtZSdcbiAgICB9KTtcblxuICAgIGNvbnN0IHNoZWxsU3R1YiA9IHNpbm9uLnN0dWIob3MsICdzaGVsbCcpLnJlamVjdHMoJ1NUT1BURVNUJyk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3QgYXNzZXQ6IGN4YXBpLkNvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5ID0ge1xuICAgICAgaWQ6ICdhc3NldElkJyxcbiAgICAgIGltYWdlTmFtZVBhcmFtZXRlcjogJ015UGFyYW1ldGVyJyxcbiAgICAgIHBhY2thZ2luZzogJ2NvbnRhaW5lci1pbWFnZScsXG4gICAgICBwYXRoOiAnL2ZvbycsXG4gICAgICBzb3VyY2VIYXNoOiAnMTIzNDU2Nzg5MGFiY2RlZicsXG4gICAgICByZXBvc2l0b3J5TmFtZTogJ3NvbWUtbmFtZScsXG4gICAgICBidWlsZEFyZ3M6IHtcbiAgICAgICAgYTogJ2InLFxuICAgICAgICBjOiAnZCdcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHByZXBhcmVDb250YWluZXJBc3NldCgnLicsIGFzc2V0LCB0b29sa2l0LCBmYWxzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEvU1RPUFRFU1QvLnRlc3QoZS50b1N0cmluZygpKSkgeyB0aHJvdyBlOyB9XG4gICAgfVxuXG4gICAgLy8gVEhFTlxuICAgIGNvbnN0IGNvbW1hbmQgPSBbJ2RvY2tlcicsICdidWlsZCcsICctLWJ1aWxkLWFyZycsICdhPWInLCAnLS1idWlsZC1hcmcnLCAnYz1kJywgJy0tdGFnJywgYHVyaTpsYXRlc3RgLCAnL2ZvbyddO1xuICAgIHRlc3Qub2soc2hlbGxTdHViLmNhbGxlZFdpdGgoY29tbWFuZCkpO1xuXG4gICAgcHJlcGFyZUVjclJlcG9zaXRvcnlTdHViLnJlc3RvcmUoKTtcbiAgICBzaGVsbFN0dWIucmVzdG9yZSgpO1xuICAgIHRlc3QuZG9uZSgpO1xuICB9LFxuXG4gIGFzeW5jICdyZWxhdGl2ZSBwYXRoJyh0ZXN0OiBUZXN0KSB7XG4gICAgLy8gR0lWRU5cbiAgICBjb25zdCB0b29sa2l0ID0gbmV3IFRvb2xraXRJbmZvKHtcbiAgICAgIHNkazogbmV3IE1vY2tTREsoKSxcbiAgICAgIGJ1Y2tldE5hbWU6ICdCVUNLRVRfTkFNRScsXG4gICAgICBidWNrZXRFbmRwb2ludDogJ0JVQ0tFVF9FTkRQT0lOVCcsXG4gICAgICBlbnZpcm9ubWVudDogeyBuYW1lOiAnZW52JywgYWNjb3VudDogJzEyMzQnLCByZWdpb246ICdhYmMnIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHByZXBhcmVFY3JSZXBvc2l0b3J5U3R1YiA9IHNpbm9uLnN0dWIodG9vbGtpdCwgJ3ByZXBhcmVFY3JSZXBvc2l0b3J5JykucmVzb2x2ZXMoe1xuICAgICAgcmVwb3NpdG9yeVVyaTogJ3VyaScsXG4gICAgICByZXBvc2l0b3J5TmFtZTogJ25hbWUnXG4gICAgfSk7XG5cbiAgICBjb25zdCBzaGVsbFN0dWIgPSBzaW5vbi5zdHViKG9zLCAnc2hlbGwnKS5yZWplY3RzKCdTVE9QVEVTVCcpO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IGFzc2V0OiBjeGFwaS5Db250YWluZXJJbWFnZUFzc2V0TWV0YWRhdGFFbnRyeSA9IHtcbiAgICAgIGlkOiAnYXNzZXRJZCcsXG4gICAgICBpbWFnZU5hbWVQYXJhbWV0ZXI6ICdNeVBhcmFtZXRlcicsXG4gICAgICBwYWNrYWdpbmc6ICdjb250YWluZXItaW1hZ2UnLFxuICAgICAgcGF0aDogJ3JlbGF0aXZlLXRvLWFzc2VtYmx5JyxcbiAgICAgIHNvdXJjZUhhc2g6ICcxMjM0NTY3ODkwYWJjZGVmJyxcbiAgICAgIHJlcG9zaXRvcnlOYW1lOiAnc29tZS1uYW1lJyxcbiAgICAgIGJ1aWxkQXJnczoge1xuICAgICAgICBhOiAnYicsXG4gICAgICAgIGM6ICdkJ1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJlcGFyZUNvbnRhaW5lckFzc2V0KCcvYXNzZW1ibHkvZGlyL3Jvb3QnLCBhc3NldCwgdG9vbGtpdCwgZmFsc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghL1NUT1BURVNULy50ZXN0KGUudG9TdHJpbmcoKSkpIHsgdGhyb3cgZTsgfVxuICAgIH1cblxuICAgIC8vIFRIRU5cbiAgICBjb25zdCBjb21tYW5kID0gWydkb2NrZXInLCAnYnVpbGQnLCAnLS1idWlsZC1hcmcnLCAnYT1iJywgJy0tYnVpbGQtYXJnJywgJ2M9ZCcsICctLXRhZycsIGB1cmk6bGF0ZXN0YCwgJy9hc3NlbWJseS9kaXIvcm9vdC9yZWxhdGl2ZS10by1hc3NlbWJseSddO1xuICAgIHRlc3Qub2soc2hlbGxTdHViLmNhbGxlZFdpdGgoY29tbWFuZCkpO1xuXG4gICAgcHJlcGFyZUVjclJlcG9zaXRvcnlTdHViLnJlc3RvcmUoKTtcbiAgICBzaGVsbFN0dWIucmVzdG9yZSgpO1xuICAgIHRlc3QuZG9uZSgpO1xuICB9XG59O1xuIl19