"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const archiver = require("archiver");
const crypto = require("crypto");
const fs = require("fs-extra");
const glob = require("glob");
const path = require("path");
function zipDirectory(directory, outputFile) {
    return new Promise((ok, fail) => {
        // The below options are needed to support following symlinks when building zip files:
        // - nodir: This will prevent symlinks themselves from being copied into the zip.
        // - follow: This will follow symlinks and copy the files within.
        const globOptions = {
            dot: true,
            nodir: true,
            follow: true,
            cwd: directory,
        };
        const files = glob.sync('**', globOptions); // The output here is already sorted
        const output = fs.createWriteStream(outputFile);
        const archive = archiver('zip');
        archive.on('warning', fail);
        archive.on('error', fail);
        archive.pipe(output);
        files.forEach(file => {
            archive.append(fs.createReadStream(path.join(directory, file)), {
                name: file,
                date: new Date('1980-01-01T00:00:00.000Z'),
            });
        });
        archive.finalize();
        // archive has been finalized and the output file descriptor has closed, resolve promise
        output.once('close', () => ok());
    });
}
exports.zipDirectory = zipDirectory;
function contentHash(data) {
    return crypto.createHash('sha256').update(data).digest('hex');
}
exports.contentHash = contentHash;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJjaGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFyY2hpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxxQ0FBc0M7QUFDdEMsaUNBQWtDO0FBQ2xDLCtCQUFnQztBQUNoQyw2QkFBOEI7QUFDOUIsNkJBQThCO0FBRTlCLFNBQWdCLFlBQVksQ0FBQyxTQUFpQixFQUFFLFVBQWtCO0lBQ2hFLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUU7UUFDOUIsc0ZBQXNGO1FBQ3RGLGlGQUFpRjtRQUNqRixpRUFBaUU7UUFDakUsTUFBTSxXQUFXLEdBQUc7WUFDbEIsR0FBRyxFQUFFLElBQUk7WUFDVCxLQUFLLEVBQUUsSUFBSTtZQUNYLE1BQU0sRUFBRSxJQUFJO1lBQ1osR0FBRyxFQUFFLFNBQVM7U0FDZixDQUFDO1FBQ0YsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxvQ0FBb0M7UUFFaEYsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRWhELE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoQyxPQUFPLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM1QixPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMxQixPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXJCLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDbkIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRTtnQkFDOUQsSUFBSSxFQUFFLElBQUk7Z0JBQ1YsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLDBCQUEwQixDQUFDO2FBQzNDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRW5CLHdGQUF3RjtRQUN4RixNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ25DLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQWhDRCxvQ0FnQ0M7QUFFRCxTQUFnQixXQUFXLENBQUMsSUFBZ0M7SUFDMUQsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDaEUsQ0FBQztBQUZELGtDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFyY2hpdmVyID0gcmVxdWlyZSgnYXJjaGl2ZXInKTtcbmltcG9ydCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmltcG9ydCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XG5pbXBvcnQgZ2xvYiA9IHJlcXVpcmUoJ2dsb2InKTtcbmltcG9ydCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5leHBvcnQgZnVuY3Rpb24gemlwRGlyZWN0b3J5KGRpcmVjdG9yeTogc3RyaW5nLCBvdXRwdXRGaWxlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChvaywgZmFpbCkgPT4ge1xuICAgIC8vIFRoZSBiZWxvdyBvcHRpb25zIGFyZSBuZWVkZWQgdG8gc3VwcG9ydCBmb2xsb3dpbmcgc3ltbGlua3Mgd2hlbiBidWlsZGluZyB6aXAgZmlsZXM6XG4gICAgLy8gLSBub2RpcjogVGhpcyB3aWxsIHByZXZlbnQgc3ltbGlua3MgdGhlbXNlbHZlcyBmcm9tIGJlaW5nIGNvcGllZCBpbnRvIHRoZSB6aXAuXG4gICAgLy8gLSBmb2xsb3c6IFRoaXMgd2lsbCBmb2xsb3cgc3ltbGlua3MgYW5kIGNvcHkgdGhlIGZpbGVzIHdpdGhpbi5cbiAgICBjb25zdCBnbG9iT3B0aW9ucyA9IHtcbiAgICAgIGRvdDogdHJ1ZSxcbiAgICAgIG5vZGlyOiB0cnVlLFxuICAgICAgZm9sbG93OiB0cnVlLFxuICAgICAgY3dkOiBkaXJlY3RvcnksXG4gICAgfTtcbiAgICBjb25zdCBmaWxlcyA9IGdsb2Iuc3luYygnKionLCBnbG9iT3B0aW9ucyk7IC8vIFRoZSBvdXRwdXQgaGVyZSBpcyBhbHJlYWR5IHNvcnRlZFxuXG4gICAgY29uc3Qgb3V0cHV0ID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ob3V0cHV0RmlsZSk7XG5cbiAgICBjb25zdCBhcmNoaXZlID0gYXJjaGl2ZXIoJ3ppcCcpO1xuICAgIGFyY2hpdmUub24oJ3dhcm5pbmcnLCBmYWlsKTtcbiAgICBhcmNoaXZlLm9uKCdlcnJvcicsIGZhaWwpO1xuICAgIGFyY2hpdmUucGlwZShvdXRwdXQpO1xuXG4gICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHsgLy8gQXBwZW5kIGZpbGVzIHNlcmlhbGx5IHRvIGVuc3VyZSBmaWxlIG9yZGVyXG4gICAgICBhcmNoaXZlLmFwcGVuZChmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGguam9pbihkaXJlY3RvcnksIGZpbGUpKSwge1xuICAgICAgICBuYW1lOiBmaWxlLFxuICAgICAgICBkYXRlOiBuZXcgRGF0ZSgnMTk4MC0wMS0wMVQwMDowMDowMC4wMDBaJyksIC8vIHJlc2V0IGRhdGVzIHRvIGdldCB0aGUgc2FtZSBoYXNoIGZvciB0aGUgc2FtZSBjb250ZW50XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFyY2hpdmUuZmluYWxpemUoKTtcblxuICAgIC8vIGFyY2hpdmUgaGFzIGJlZW4gZmluYWxpemVkIGFuZCB0aGUgb3V0cHV0IGZpbGUgZGVzY3JpcHRvciBoYXMgY2xvc2VkLCByZXNvbHZlIHByb21pc2VcbiAgICBvdXRwdXQub25jZSgnY2xvc2UnLCAoKSA9PiBvaygpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb250ZW50SGFzaChkYXRhOiBzdHJpbmcgfCBCdWZmZXIgfCBEYXRhVmlldykge1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShkYXRhKS5kaWdlc3QoJ2hleCcpO1xufVxuIl19