"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const logging_1 = require("./logging");
const os_1 = require("./os");
/**
 * Build and upload a Docker image
 *
 * Permanently identifying images is a bit of a bust. Newer Docker version use
 * a digest (sha256:xxxx) as an image identifier, which is pretty good to avoid
 * spurious rebuilds. However, this digest is calculated over a manifest that
 * includes metadata that is liable to change. For example, as soon as we
 * push the Docker image to a repository, the digest changes. This makes the
 * digest worthless to determe whether we already pushed an image, for example.
 *
 * As a workaround, we calculate our own digest over parts of the manifest that
 * are unlikely to change, and tag based on that.
 *
 * When running in CI, we pull the latest image first and use it as cache for
 * the build. Generally pulling will be faster than building, especially for
 * Dockerfiles with lots of OS/code packages installation or changes only in
 * the bottom layers. When running locally chances are that we already have
 * layers cache available.
 *
 * CI is detected by the presence of the `CI` environment variable or
 * the `--ci` command line option.
 */
async function prepareContainerAsset(assemblyDir, asset, toolkitInfo, reuse, ci) {
    if (reuse) {
        return [
            { ParameterKey: asset.imageNameParameter, UsePreviousValue: true },
        ];
    }
    const contextPath = path.isAbsolute(asset.path) ? asset.path : path.join(assemblyDir, asset.path);
    logging_1.debug(' ðŸ‘‘  Preparing Docker image asset:', contextPath);
    try {
        const ecr = await toolkitInfo.prepareEcrRepository(asset);
        const latest = `${ecr.repositoryUri}:latest`;
        let loggedIn = false;
        // In CI we try to pull latest first
        if (ci) {
            await dockerLogin(toolkitInfo);
            loggedIn = true;
            try {
                await os_1.shell(['docker', 'pull', latest]);
            }
            catch (e) {
                logging_1.debug('Failed to pull latest image from ECR repository');
            }
        }
        const buildArgs = [].concat(...Object.entries(asset.buildArgs || {}).map(([k, v]) => ['--build-arg', `${k}=${v}`]));
        const baseCommand = [
            'docker', 'build',
            ...buildArgs,
            '--tag', latest,
            contextPath
        ];
        const command = ci
            ? [...baseCommand, '--cache-from', latest] // This does not fail if latest is not available
            : baseCommand;
        await os_1.shell(command);
        // Login and push
        if (!loggedIn) { // We could be already logged in if in CI
            await dockerLogin(toolkitInfo);
            loggedIn = true;
        }
        // There's no way to make this quiet, so we can't use a PleaseHold. Print a header message.
        logging_1.print(` âŒ› Pushing Docker image for ${contextPath}; this may take a while.`);
        await os_1.shell(['docker', 'push', latest]);
        logging_1.debug(` ðŸ‘‘  Docker image for ${contextPath} pushed.`);
        // Get the (single) repo-digest for latest, which'll be <ecr.repositoryUrl>@sha256:<repoImageSha256>
        const repoDigests = (await os_1.shell(['docker', 'image', 'inspect', latest, '--format', '{{range .RepoDigests}}{{.}}|{{end}}'])).trim();
        const requiredPrefix = `${ecr.repositoryUri}@sha256:`;
        const repoDigest = repoDigests.split('|').find(digest => digest.startsWith(requiredPrefix));
        if (!repoDigest) {
            throw new Error(`Unable to identify repository digest (none starts with ${requiredPrefix}) in:\n${repoDigests}`);
        }
        return [
            { ParameterKey: asset.imageNameParameter, ParameterValue: repoDigest.replace(ecr.repositoryUri, ecr.repositoryName) },
        ];
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            // tslint:disable-next-line:max-line-length
            throw new Error('Error building Docker image asset; you need to have Docker installed in order to be able to build image assets. Please install Docker and try again.');
        }
        throw e;
    }
}
exports.prepareContainerAsset = prepareContainerAsset;
/**
 * Get credentials from ECR and run docker login
 */
async function dockerLogin(toolkitInfo) {
    const credentials = await toolkitInfo.getEcrCredentials();
    await os_1.shell(['docker', 'login',
        '--username', credentials.username,
        '--password', credentials.password,
        credentials.endpoint]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG9ja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsNkJBQThCO0FBRTlCLHVDQUF5QztBQUN6Qyw2QkFBNkI7QUFFN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNJLEtBQUssVUFBVSxxQkFBcUIsQ0FBQyxXQUFtQixFQUNuQixLQUF1QyxFQUN2QyxXQUF3QixFQUN4QixLQUFjLEVBQ2QsRUFBWTtJQUV0RCxJQUFJLEtBQUssRUFBRTtRQUNULE9BQU87WUFDTCxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFO1NBQ25FLENBQUM7S0FDSDtJQUVELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFbEcsZUFBSyxDQUFDLG9DQUFvQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBRXpELElBQUk7UUFDRixNQUFNLEdBQUcsR0FBRyxNQUFNLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxRCxNQUFNLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxhQUFhLFNBQVMsQ0FBQztRQUU3QyxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFFckIsb0NBQW9DO1FBQ3BDLElBQUksRUFBRSxFQUFFO1lBQ04sTUFBTSxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDL0IsUUFBUSxHQUFHLElBQUksQ0FBQztZQUVoQixJQUFJO2dCQUNGLE1BQU0sVUFBSyxDQUFDLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO2FBQ3pDO1lBQUMsT0FB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bnRlbnQiOlsiaW1wb3J0IHsgQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnkgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb24gfSBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuaW1wb3J0IHsgVG9vbGtpdEluZm8gfSBmcm9tICcuL2FwaS90b29sa2l0LWluZm8nO1xuaW1wb3J0IHsgZGVidWcsIHByaW50IH0gZnJvbSAnLi9sb2dnaW5nJztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi9vcyc7XG5cbi8qKlxuICogQnVpbGQgYW5kIHVwbG9hZCBhIERvY2tlciBpbWFnZVxuICpcbiAqIFBlcm1hbmVudGx5IGlkZW50aWZ5aW5nIGltYWdlcyBpcyBhIGJpdCBvZiBhIGJ1c3QuIE5ld2VyIERvY2tlciB2ZXJzaW9uIHVzZVxuICogYSBkaWdlc3QgKHNoYTI1Njp4eHh4KSBhcyBhbiBpbWFnZSBpZGVudGlmaWVyLCB3aGljaCBpcyBwcmV0dHkgZ29vZCB0byBhdm9pZFxuICogc3B1cmlvdXMgcmVidWlsZHMuIEhvd2V2ZXIsIHRoaXMgZGlnZXN0IGlzIGNhbGN1bGF0ZWQgb3ZlciBhIG1hbmlmZXN0IHRoYXRcbiAqIGluY2x1ZGVzIG1ldGFkYXRhIHRoYXQgaXMgbGlhYmxlIHRvIGNoYW5nZS4gRm9yIGV4YW1wbGUsIGFzIHNvb24gYXMgd2VcbiAqIHB1c2ggdGhlIERvY2tlciBpbWFnZSB0byBhIHJlcG9zaXRvcnksIHRoZSBkaWdlc3QgY2hhbmdlcy4gVGhpcyBtYWtlcyB0aGVcbiAqIGRpZ2VzdCB3b3J0aGxlc3MgdG8gZGV0ZXJtZSB3aGV0aGVyIHdlIGFscmVhZHkgcHVzaGVkIGFuIGltYWdlLCBmb3IgZXhhbXBsZS5cbiAqXG4gKiBBcyBhIHdvcmthcm91bmQsIHdlIGNhbGN1bGF0ZSBvdXIgb3duIGRpZ2VzdCBvdmVyIHBhcnRzIG9mIHRoZSBtYW5pZmVzdCB0aGF0XG4gKiBhcmUgdW5saWtlbHkgdG8gY2hhbmdlLCBhbmQgdGFnIGJhc2VkIG9uIHRoYXQuXG4gKlxuICogV2hlbiBydW5uaW5nIGluIENJLCB3ZSBwdWxsIHRoZSBsYXRlc3QgaW1hZ2UgZmlyc3QgYW5kIHVzZSBpdCBhcyBjYWNoZSBmb3JcbiAqIHRoZSBidWlsZC4gR2VuZXJhbGx5IHB1bGxpbmcgd2lsbCBiZSBmYXN0ZXIgdGhhbiBidWlsZGluZywgZXNwZWNpYWxseSBmb3JcbiAqIERvY2tlcmZpbGVzIHdpdGggbG90cyBvZiBPUy9jb2RlIHBhY2thZ2VzIGluc3RhbGxhdGlvbiBvciBjaGFuZ2VzIG9ubHkgaW5cbiAqIHRoZSBib3R0b20gbGF5ZXJzLiBXaGVuIHJ1bm5pbmcgbG9jYWxseSBjaGFuY2VzIGFyZSB0aGF0IHdlIGFscmVhZHkgaGF2ZVxuICogbGF5ZXJzIGNhY2hlIGF2YWlsYWJsZS5cbiAqXG4gKiBDSSBpcyBkZXRlY3RlZCBieSB0aGUgcHJlc2VuY2Ugb2YgdGhlIGBDSWAgZW52aXJvbm1lbnQgdmFyaWFibGUgb3JcbiAqIHRoZSBgLS1jaWAgY29tbWFuZCBsaW5lIG9wdGlvbi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVDb250YWluZXJBc3NldChhc3NlbWJseURpcjogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NldDogQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV1c2U6IGJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpPzogYm9vbGVhbik6IFByb21pc2U8W0Nsb3VkRm9ybWF0aW9uLlBhcmFtZXRlcl0+IHtcblxuICBpZiAocmV1c2UpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyBQYXJhbWV0ZXJLZXk6IGFzc2V0LmltYWdlTmFtZVBhcmFtZXRlciwgVXNlUHJldmlvdXNWYWx1ZTogdHJ1ZSB9LFxuICAgIF07XG4gIH1cblxuICBjb25zdCBjb250ZXh0UGF0aCA9IHBhdGguaXNBYnNvbHV0ZShhc3NldC5wYXRoKSA/IGFzc2V0LnBhdGggOiBwYXRoLmpvaW4oYXNzZW1ibHlEaXIsIGFzc2V0LnBhdGgpO1xuXG4gIGRlYnVnKCcg8J+RkSAgUHJlcGFyaW5nIERvY2tlciBpbWFnZSBhc3NldDonLCBjb250ZXh0UGF0aCk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBlY3IgPSBhd2FpdCB0b29sa2l0SW5mby5wcmVwYXJlRWNyUmVwb3NpdG9yeShhc3NldCk7XG4gICAgY29uc3QgbGF0ZXN0ID0gYCR7ZWNyLnJlcG9zaXRvcnlVcml9OmxhdGVzdGA7XG5cbiAgICBsZXQgbG9nZ2VkSW4gPSBmYWxzZTtcblxuICAgIC8vIEluIENJIHdlIHRyeSB0byBwdWxsIGxhdGVzdCBmaXJzdFxuICAgIGlmIChjaSkge1xuICAgICAgYXdhaXQgZG9ja2VyTG9naW4odG9vbGtpdEluZm8pO1xuICAgICAgbG9nZ2VkSW4gPSB0cnVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdwdWxsJywgbGF0ZXN0XSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnKCdGYWlsZWQgdG8gcHVsbCBsYXRlc3QgaW1hZ2UgZnJvbSBFQ1IgcmVwb3NpdG9yeScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJ1aWxkQXJncyA9IChbXSBhcyBzdHJpbmdbXSkuY29uY2F0KC4uLk9iamVjdC5lbnRyaWVzKGFzc2V0LmJ1aWxkQXJncyB8fCB7fSkubWFwKChbaywgdl0pID0+IFsnLS1idWlsZC1hcmcnLCBgJHtrfT0ke3Z9YF0pKTtcbiAgICBjb25zdCBiYXNlQ29tbWFuZCA9IFtcbiAgICAgICdkb2NrZXInLCAnYnVpbGQnLFxuICAgICAgLi4uYnVpbGRBcmdzLFxuICAgICAgJy0tdGFnJywgbGF0ZXN0LFxuICAgICAgY29udGV4dFBhdGhcbiAgICBdO1xuXG4gICAgY29uc3QgY29tbWFuZCA9IGNpXG4gICAgICA/IFsuLi5iYXNlQ29tbWFuZCwgJy0tY2FjaGUtZnJvbScsIGxhdGVzdF0gLy8gVGhpcyBkb2VzIG5vdCBmYWlsIGlmIGxhdGVzdCBpcyBub3QgYXZhaWxhYmxlXG4gICAgICA6IGJhc2VDb21tYW5kO1xuICAgIGF3YWl0IHNoZWxsKGNvbW1hbmQpO1xuXG4gICAgLy8gTG9naW4gYW5kIHB1c2hcbiAgICBpZiAoIWxvZ2dlZEluKSB7IC8vIFdlIGNvdWxkIGJlIGFscmVhZHkgbG9nZ2VkIGluIGlmIGluIENJXG4gICAgICBhd2FpdCBkb2NrZXJMb2dpbih0b29sa2l0SW5mbyk7XG4gICAgICBsb2dnZWRJbiA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gVGhlcmUncyBubyB3YXkgdG8gbWFrZSB0aGlzIHF1aWV0LCBzbyB3ZSBjYW4ndCB1c2UgYSBQbGVhc2VIb2xkLiBQcmludCBhIGhlYWRlciBtZXNzYWdlLlxuICAgIHByaW50KGAg4oybIFB1c2hpbmcgRG9ja2VyIGltYWdlIGZvciAke2NvbnRleHRQYXRofTsgdGhpcyBtYXkgdGFrZSBhIHdoaWxlLmApO1xuICAgIGF3YWl0IHNoZWxsKFsnZG9ja2VyJywgJ3B1c2gnLCBsYXRlc3RdKTtcbiAgICBkZWJ1ZyhgIPCfkZEgIERvY2tlciBpbWFnZSBmb3IgJHtjb250ZXh0UGF0aH0gcHVzaGVkLmApO1xuXG4gICAgLy8gR2V0IHRoZSAoc2luZ2xlKSByZXBvLWRpZ2VzdCBmb3IgbGF0ZXN0LCB3aGljaCdsbCBiZSA8ZWNyLnJlcG9zaXRvcnlVcmw+QHNoYTI1Njo8cmVwb0ltYWdlU2hhMjU2PlxuICAgIGNvbnN0IHJlcG9EaWdlc3RzID0gKGF3YWl0IHNoZWxsKFsnZG9ja2VyJywgJ2ltYWdlJywgJ2luc3BlY3QnLCBsYXRlc3QsICctLWZvcm1hdCcsICd7e3JhbmdlIC5SZXBvRGlnZXN0c319e3sufX18e3tlbmR9fSddKSkudHJpbSgpO1xuICAgIGNvbnN0IHJlcXVpcmVkUHJlZml4ID0gYCR7ZWNyLnJlcG9zaXRvcnlVcml9QHNoYTI1NjpgO1xuICAgIGNvbnN0IHJlcG9EaWdlc3QgPSByZXBvRGlnZXN0cy5zcGxpdCgnfCcpLmZpbmQoZGlnZXN0ID0+IGRpZ2VzdC5zdGFydHNXaXRoKHJlcXVpcmVkUHJlZml4KSk7XG4gICAgaWYgKCFyZXBvRGlnZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBpZGVudGlmeSByZXBvc2l0b3J5IGRpZ2VzdCAobm9uZSBzdGFydHMgd2l0aCAke3JlcXVpcmVkUHJlZml4fSkgaW46XFxuJHtyZXBvRGlnZXN0c31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgeyBQYXJhbWV0ZXJLZXk6IGFzc2V0LmltYWdlTmFtZVBhcmFtZXRlciwgUGFyYW1ldGVyVmFsdWU6IHJlcG9EaWdlc3QucmVwbGFjZShlY3IucmVwb3NpdG9yeVVyaSwgZWNyLnJlcG9zaXRvcnlOYW1lKSB9LFxuICAgIF07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBidWlsZGluZyBEb2NrZXIgaW1hZ2UgYXNzZXQ7IHlvdSBuZWVkIHRvIGhhdmUgRG9ja2VyIGluc3RhbGxlZCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIGJ1aWxkIGltYWdlIGFzc2V0cy4gUGxlYXNlIGluc3RhbGwgRG9ja2VyIGFuZCB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgY3JlZGVudGlhbHMgZnJvbSBFQ1IgYW5kIHJ1biBkb2NrZXIgbG9naW5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZG9ja2VyTG9naW4odG9vbGtpdEluZm86IFRvb2xraXRJbmZvKSB7XG4gIGNvbnN0IGNyZWRlbnRpYWxzID0gYXdhaXQgdG9vbGtpdEluZm8uZ2V0RWNyQ3JlZGVudGlhbHMoKTtcbiAgYXdhaXQgc2hlbGwoWydkb2NrZXInLCAnbG9naW4nLFxuICAnLS11c2VybmFtZScsIGNyZWRlbnRpYWxzLnVzZXJuYW1lLFxuICAnLS1wYXNzd29yZCcsIGNyZWRlbnRpYWxzLnBhc3N3b3JkLFxuICBjcmVkZW50aWFscy5lbmRwb2ludF0pO1xufVxuIl19