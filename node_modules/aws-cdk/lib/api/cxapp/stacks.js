"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const regionInfo = require("@aws-cdk/region-info");
const colors = require("colors/safe");
const minimatch = require("minimatch");
const contextproviders = require("../../context-providers");
const logging_1 = require("../../logging");
const arrays_1 = require("../../util/arrays");
var DefaultSelection;
(function (DefaultSelection) {
    /**
     * Returns an empty selection in case there are no selectors.
     */
    DefaultSelection["None"] = "none";
    /**
     * If the app includes a single stack, returns it. Otherwise throws an exception.
     * This behavior is used by "deploy".
     */
    DefaultSelection["OnlySingle"] = "single";
    /**
     * If no selectors are provided, returns all stacks in the app.
     */
    DefaultSelection["AllStacks"] = "all";
})(DefaultSelection = exports.DefaultSelection || (exports.DefaultSelection = {}));
/**
 * Routines to get stacks from an app
 *
 * In a class because it shares some global state
 */
class AppStacks {
    constructor(props) {
        this.props = props;
    }
    /**
     * List all stacks in the CX and return the selected ones
     *
     * It's an error if there are no stacks to select, or if one of the requested parameters
     * refers to a nonexistant stack.
     */
    async selectStacks(selectors, options) {
        selectors = selectors.filter(s => s != null); // filter null/undefined
        const stacks = await this.listStacks();
        if (stacks.length === 0) {
            throw new Error('This app contains no stacks');
        }
        if (selectors.length === 0) {
            switch (options.defaultBehavior) {
                case DefaultSelection.AllStacks:
                    return stacks;
                case DefaultSelection.None:
                    return [];
                case DefaultSelection.OnlySingle:
                    if (stacks.length === 1) {
                        return stacks;
                    }
                    else {
                        throw new Error(`Since this app includes more than a single stack, specify which stacks to use (wildcards are supported)\n` +
                            `Stacks: ${stacks.map(x => x.name).join(' ')}`);
                    }
                default:
                    throw new Error(`invalid default behavior: ${options.defaultBehavior}`);
            }
        }
        const allStacks = new Map();
        for (const stack of stacks) {
            allStacks.set(stack.name, stack);
        }
        // For every selector argument, pick stacks from the list.
        const selectedStacks = new Map();
        for (const pattern of selectors) {
            let found = false;
            for (const stack of stacks) {
                if (minimatch(stack.name, pattern) && !selectedStacks.has(stack.name)) {
                    selectedStacks.set(stack.name, stack);
                    found = true;
                }
            }
            if (!found) {
                throw new Error(`No stack found matching '${pattern}'. Use "list" to print manifest`);
            }
        }
        const extend = options.extend || ExtendedStackSelection.None;
        switch (extend) {
            case ExtendedStackSelection.Downstream:
                includeDownstreamStacks(selectedStacks, allStacks);
                break;
            case ExtendedStackSelection.Upstream:
                includeUpstreamStacks(selectedStacks, allStacks);
                break;
        }
        // Filter original array because it is in the right order
        const selectedList = stacks.filter(s => selectedStacks.has(s.name));
        return selectedList;
    }
    /**
     * Return all stacks in the CX
     *
     * If the stacks have dependencies between them, they will be returned in
     * topologically sorted order. If there are dependencies that are not in the
     * set, they will be ignored; it is the user's responsibility that the
     * non-selected stacks have already been deployed previously.
     */
    async listStacks() {
        const response = await this.synthesizeStacks();
        return response.stacks;
    }
    /**
     * Synthesize a single stack
     */
    async synthesizeStack(stackName) {
        const resp = await this.synthesizeStacks();
        const stack = resp.getStack(stackName);
        return stack;
    }
    /**
     * Synthesize a set of stacks
     */
    async synthesizeStacks() {
        if (this.assembly) {
            return this.assembly;
        }
        const trackVersions = this.props.configuration.settings.get(['versionReporting']);
        // We may need to run the cloud executable multiple times in order to satisfy all missing context
        while (true) {
            const assembly = await this.props.synthesizer(this.props.aws, this.props.configuration);
            if (assembly.manifest.missing) {
                logging_1.debug(`Some context information is missing. Fetching...`);
                await contextproviders.provideContextValues(assembly.manifest.missing, this.props.configuration.context, this.props.aws);
                // Cache the new context to disk
                await this.props.configuration.saveContext();
                continue;
            }
            if (trackVersions && assembly.runtime) {
                const modules = formatModules(assembly.runtime);
                for (const stack of assembly.stacks) {
                    if (!stack.template.Resources) {
                        stack.template.Resources = {};
                    }
                    const resourcePresent = stack.environment.region === cxapi.UNKNOWN_REGION
                        || regionInfo.Fact.find(stack.environment.region, regionInfo.FactName.CDK_METADATA_RESOURCE_AVAILABLE) === 'YES';
                    if (resourcePresent) {
                        if (!stack.template.Resources.CDKMetadata) {
                            stack.template.Resources.CDKMetadata = {
                                Type: 'AWS::CDK::Metadata',
                                Properties: {
                                    Modules: modules
                                }
                            };
                        }
                        else {
                            logging_1.warning(`The stack ${stack.name} already includes a CDKMetadata resource`);
                        }
                    }
                }
            }
            // All good, return
            this.assembly = assembly;
            return assembly;
            function formatModules(runtime) {
                const modules = new Array();
                // inject toolkit version to list of modules
                const toolkitVersion = require('../../../package.json').version;
                modules.push(`aws-cdk=${toolkitVersion}`);
                for (const key of Object.keys(runtime.libraries).sort()) {
                    modules.push(`${key}=${runtime.libraries[key]}`);
                }
                return modules.join(',');
            }
        }
    }
    /**
     * @returns an array with the tags available in the stack metadata.
     */
    getTagsFromStackMetadata(stack) {
        return arrays_1.flatMap(stack.findMetadataByType(cxapi.STACK_TAGS_METADATA_KEY), x => x.data);
    }
    /**
     * Extracts 'aws:cdk:warning|info|error' metadata entries from the stack synthesis
     */
    processMetadata(stacks) {
        let warnings = false;
        let errors = false;
        for (const stack of stacks) {
            for (const message of stack.messages) {
                switch (message.level) {
                    case cxapi.SynthesisMessageLevel.WARNING:
                        warnings = true;
                        this.printMessage(logging_1.warning, 'Warning', message.id, message.entry);
                        break;
                    case cxapi.SynthesisMessageLevel.ERROR:
                        errors = true;
                        this.printMessage(logging_1.error, 'Error', message.id, message.entry);
                        break;
                    case cxapi.SynthesisMessageLevel.INFO:
                        this.printMessage(logging_1.print, 'Info', message.id, message.entry);
                        break;
                }
            }
        }
        if (errors && !this.props.ignoreErrors) {
            throw new Error('Found errors');
        }
        if (this.props.strict && warnings) {
            throw new Error('Found warnings (--strict mode)');
        }
    }
    printMessage(logFn, prefix, id, entry) {
        logFn(`[${prefix} at ${id}] ${entry.data}`);
        if (this.props.verbose && entry.trace) {
            logFn(`  ${entry.trace.join('\n  ')}`);
        }
    }
}
exports.AppStacks = AppStacks;
/**
 * Combine the names of a set of stacks using a comma
 */
function listStackNames(stacks) {
    return stacks.map(s => s.name).join(', ');
}
exports.listStackNames = listStackNames;
/**
 * When selecting stacks, what other stacks to include because of dependencies
 */
var ExtendedStackSelection;
(function (ExtendedStackSelection) {
    /**
     * Don't select any extra stacks
     */
    ExtendedStackSelection[ExtendedStackSelection["None"] = 0] = "None";
    /**
     * Include stacks that this stack depends on
     */
    ExtendedStackSelection[ExtendedStackSelection["Upstream"] = 1] = "Upstream";
    /**
     * Include stacks that depend on this stack
     */
    ExtendedStackSelection[ExtendedStackSelection["Downstream"] = 2] = "Downstream";
})(ExtendedStackSelection = exports.ExtendedStackSelection || (exports.ExtendedStackSelection = {}));
/**
 * Include stacks that depend on the stacks already in the set
 *
 * Modifies `selectedStacks` in-place.
 */
function includeDownstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const [name, stack] of allStacks) {
            // Select this stack if it's not selected yet AND it depends on a stack that's in the selected set
            if (!selectedStacks.has(name) && (stack.dependencies || []).some(dep => selectedStacks.has(dep.id))) {
                selectedStacks.set(name, stack);
                added.push(name);
                madeProgress = true;
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including depending stacks: %s', colors.bold(added.join(', ')));
    }
}
/**
 * Include stacks that that stacks in the set depend on
 *
 * Modifies `selectedStacks` in-place.
 */
function includeUpstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const stack of selectedStacks.values()) {
            // Select an additional stack if it's not selected yet and a dependency of a selected stack (and exists, obviously)
            for (const dependencyName of stack.dependencies.map(x => x.id)) {
                if (!selectedStacks.has(dependencyName) && allStacks.has(dependencyName)) {
                    added.push(dependencyName);
                    selectedStacks.set(dependencyName, allStacks.get(dependencyName));
                    madeProgress = true;
                }
            }
        }
    }
    if (added.length > 0) {
        logging_1.print('Including dependency stacks: %s', colors.bold(added.join(', ')));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2tzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3RhY2tzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQTBDO0FBQzFDLG1EQUFvRDtBQUNwRCxzQ0FBdUM7QUFDdkMsdUNBQXdDO0FBQ3hDLDREQUE2RDtBQUM3RCwyQ0FBNkQ7QUFFN0QsOENBQTRDO0FBMkQ1QyxJQUFZLGdCQWdCWDtBQWhCRCxXQUFZLGdCQUFnQjtJQUMxQjs7T0FFRztJQUNILGlDQUFhLENBQUE7SUFFYjs7O09BR0c7SUFDSCx5Q0FBcUIsQ0FBQTtJQUVyQjs7T0FFRztJQUNILHFDQUFpQixDQUFBO0FBQ25CLENBQUMsRUFoQlcsZ0JBQWdCLEdBQWhCLHdCQUFnQixLQUFoQix3QkFBZ0IsUUFnQjNCO0FBRUQ7Ozs7R0FJRztBQUNILE1BQWEsU0FBUztJQVFwQixZQUE2QixLQUFxQjtRQUFyQixVQUFLLEdBQUwsS0FBSyxDQUFnQjtJQUFHLENBQUM7SUFFdEQ7Ozs7O09BS0c7SUFDSSxLQUFLLENBQUMsWUFBWSxDQUFDLFNBQW1CLEVBQUUsT0FBNEI7UUFDekUsU0FBUyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyx3QkFBd0I7UUFFdEUsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkMsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7U0FDaEQ7UUFFRCxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzFCLFFBQVEsT0FBTyxDQUFDLGVBQWUsRUFBRTtnQkFDL0IsS0FBSyxnQkFBZ0IsQ0FBQyxTQUFTO29CQUM3QixPQUFPLE1BQU0sQ0FBQztnQkFDaEIsS0FBSyxnQkFBZ0IsQ0FBQyxJQUFJO29CQUN4QixP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QUUsQ0FBQyxFQUFFO2dCQUM5RCxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsSUFBSSxTQUFTLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFO29CQUN4RSxLQUFLLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO29CQUMzQixjQUFjLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBRSxDQUFDLENBQUM7b0JBQ25FLFlBQVksR0FBRyxJQUFJLENBQUM7aUJBQ3JCO2FBQ0Y7U0FDRjtLQUNGO0lBRUQsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUNwQixlQUFLLENBQUMsaUNBQWlDLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN6RTtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3hhcGkgPSByZXF1aXJlKCdAYXdzLWNkay9jeC1hcGknKTtcbmltcG9ydCByZWdpb25JbmZvID0gcmVxdWlyZSgnQGF3cy1jZGsvcmVnaW9uLWluZm8nKTtcbmltcG9ydCBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMvc2FmZScpO1xuaW1wb3J0IG1pbmltYXRjaCA9IHJlcXVpcmUoJ21pbmltYXRjaCcpO1xuaW1wb3J0IGNvbnRleHRwcm92aWRlcnMgPSByZXF1aXJlKCcuLi8uLi9jb250ZXh0LXByb3ZpZGVycycpO1xuaW1wb3J0IHsgZGVidWcsIGVycm9yLCBwcmludCwgd2FybmluZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCB7IGZsYXRNYXAgfSBmcm9tICcuLi8uLi91dGlsL2FycmF5cyc7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi4vdXRpbC9zZGsnO1xuXG4vKipcbiAqIEByZXR1cm5zIG91dHB1dCBkaXJlY3RvcnlcbiAqL1xudHlwZSBTeW50aGVzaXplciA9IChhd3M6IElTREssIGNvbmZpZzogQ29uZmlndXJhdGlvbikgPT4gUHJvbWlzZTxjeGFwaS5DbG91ZEFzc2VtYmx5PjtcblxuZXhwb3J0IGludGVyZmFjZSBBcHBTdGFja3NQcm9wcyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGJlIHZlcmJvc2VcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHZlcmJvc2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEb24ndCBzdG9wIG9uIGVycm9yIG1ldGFkYXRhXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpZ25vcmVFcnJvcnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUcmVhdCB3YXJuaW5ncyBpbiBtZXRhZGF0YSBhcyBlcnJvcnNcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHN0cmljdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEFwcGxpY2F0aW9uIGNvbmZpZ3VyYXRpb24gKHNldHRpbmdzIGFuZCBjb250ZXh0KVxuICAgKi9cbiAgY29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbjtcblxuICAvKipcbiAgICogQVdTIG9iamVjdCAodXNlZCBieSBzeW50aGVzaXplciBhbmQgY29udGV4dHByb3ZpZGVyKVxuICAgKi9cbiAgYXdzOiBJU0RLO1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBpbnZva2VkIHRvIHN5bnRoZXNpemUgdGhlIGFjdHVhbCBzdGFja3NcbiAgICovXG4gIHN5bnRoZXNpemVyOiBTeW50aGVzaXplcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RTdGFja3NPcHRpb25zIHtcbiAgLyoqXG4gICAqIEV4dGVuZCB0aGUgc2VsZWN0aW9uIHRvIHVwc3RyZWFkL2Rvd25zdHJlYW0gc3RhY2tzXG4gICAqIEBkZWZhdWx0IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uTm9uZSBvbmx5IHNlbGVjdCB0aGUgc3BlY2lmaWVkIHN0YWNrcy5cbiAgICovXG4gIGV4dGVuZD86IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBiZWhhdmlvciBpZiBpZiBubyBzZWxlY3RvcnMgYXJlIHByaXZpZGVkLlxuICAgKi9cbiAgZGVmYXVsdEJlaGF2aW9yOiBEZWZhdWx0U2VsZWN0aW9uO1xufVxuXG5leHBvcnQgZW51bSBEZWZhdWx0U2VsZWN0aW9uIHtcbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZW1wdHkgc2VsZWN0aW9uIGluIGNhc2UgdGhlcmUgYXJlIG5vIHNlbGVjdG9ycy5cbiAgICovXG4gIE5vbmUgPSAnbm9uZScsXG5cbiAgLyoqXG4gICAqIElmIHRoZSBhcHAgaW5jbHVkZXMgYSBzaW5nbGUgc3RhY2ssIHJldHVybnMgaXQuIE90aGVyd2lzZSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgKiBUaGlzIGJlaGF2aW9yIGlzIHVzZWQgYnkgXCJkZXBsb3lcIi5cbiAgICovXG4gIE9ubHlTaW5nbGUgPSAnc2luZ2xlJyxcblxuICAvKipcbiAgICogSWYgbm8gc2VsZWN0b3JzIGFyZSBwcm92aWRlZCwgcmV0dXJucyBhbGwgc3RhY2tzIGluIHRoZSBhcHAuXG4gICAqL1xuICBBbGxTdGFja3MgPSAnYWxsJyxcbn1cblxuLyoqXG4gKiBSb3V0aW5lcyB0byBnZXQgc3RhY2tzIGZyb20gYW4gYXBwXG4gKlxuICogSW4gYSBjbGFzcyBiZWNhdXNlIGl0IHNoYXJlcyBzb21lIGdsb2JhbCBzdGF0ZVxuICovXG5leHBvcnQgY2xhc3MgQXBwU3RhY2tzIHtcblxuICAvKipcbiAgICogU2luY2UgYXBwIGV4ZWN1dGlvbiBiYXNpY2FsbHkgYWx3YXlzIHN5bnRoZXNpemVzIGFsbCB0aGUgc3RhY2tzLFxuICAgKiB3ZSBjYW4gaW52b2tlIGl0IG9uY2UgYW5kIGNhY2hlIHRoZSByZXNwb25zZSBmb3Igc3Vic2VxdWVudCBjYWxscy5cbiAgICovXG4gIHB1YmxpYyBhc3NlbWJseT86IGN4YXBpLkNsb3VkQXNzZW1ibHk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9wczogQXBwU3RhY2tzUHJvcHMpIHt9XG5cbiAgLyoqXG4gICAqIExpc3QgYWxsIHN0YWNrcyBpbiB0aGUgQ1ggYW5kIHJldHVybiB0aGUgc2VsZWN0ZWQgb25lc1xuICAgKlxuICAgKiBJdCdzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBubyBzdGFja3MgdG8gc2VsZWN0LCBvciBpZiBvbmUgb2YgdGhlIHJlcXVlc3RlZCBwYXJhbWV0ZXJzXG4gICAqIHJlZmVycyB0byBhIG5vbmV4aXN0YW50IHN0YWNrLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNlbGVjdFN0YWNrcyhzZWxlY3RvcnM6IHN0cmluZ1tdLCBvcHRpb25zOiBTZWxlY3RTdGFja3NPcHRpb25zKTogUHJvbWlzZTxjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXT4ge1xuICAgIHNlbGVjdG9ycyA9IHNlbGVjdG9ycy5maWx0ZXIocyA9PiBzICE9IG51bGwpOyAvLyBmaWx0ZXIgbnVsbC91bmRlZmluZWRcblxuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IHRoaXMubGlzdFN0YWNrcygpO1xuICAgIGlmIChzdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYXBwIGNvbnRhaW5zIG5vIHN0YWNrcycpO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuZGVmYXVsdEJlaGF2aW9yKSB7XG4gICAgICAgIGNhc2UgRGVmYXVsdFNlbGVjdGlvbi5BbGxTdGFja3M6XG4gICAgICAgICAgcmV0dXJuIHN0YWNrcztcbiAgICAgICAgY2FzZSBEZWZhdWx0U2VsZWN0aW9uLk5vbmU6XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBjYXNlIERlZmF1bHRTZWxlY3Rpb24uT25seVNpbmdsZTpcbiAgICAgICAgICBpZiAoc3RhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaW5jZSB0aGlzIGFwcCBpbmNsdWRlcyBtb3JlIHRoYW4gYSBzaW5nbGUgc3RhY2ssIHNwZWNpZnkgd2hpY2ggc3RhY2tzIHRvIHVzZSAod2lsZGNhcmRzIGFyZSBzdXBwb3J0ZWQpXFxuYCArXG4gICAgICAgICAgICAgIGBTdGFja3M6ICR7c3RhY2tzLm1hcCh4ID0+IHgubmFtZSkuam9pbignICcpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGVmYXVsdCBiZWhhdmlvcjogJHtvcHRpb25zLmRlZmF1bHRCZWhhdmlvcn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhbGxTdGFja3MgPSBuZXcgTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PigpO1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBhbGxTdGFja3Muc2V0KHN0YWNrLm5hbWUsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgZXZlcnkgc2VsZWN0b3IgYXJndW1lbnQsIHBpY2sgc3RhY2tzIGZyb20gdGhlIGxpc3QuXG4gICAgY29uc3Qgc2VsZWN0ZWRTdGFja3MgPSBuZXcgTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PigpO1xuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBzZWxlY3RvcnMpIHtcbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcykge1xuICAgICAgICBpZiAobWluaW1hdGNoKHN0YWNrLm5hbWUsIHBhdHRlcm4pICYmICFzZWxlY3RlZFN0YWNrcy5oYXMoc3RhY2submFtZSkpIHtcbiAgICAgICAgICBzZWxlY3RlZFN0YWNrcy5zZXQoc3RhY2submFtZSwgc3RhY2spO1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3RhY2sgZm91bmQgbWF0Y2hpbmcgJyR7cGF0dGVybn0nLiBVc2UgXCJsaXN0XCIgdG8gcHJpbnQgbWFuaWZlc3RgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBleHRlbmQgPSBvcHRpb25zLmV4dGVuZCB8fCBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLk5vbmU7XG4gICAgc3dpdGNoIChleHRlbmQpIHtcbiAgICAgIGNhc2UgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Eb3duc3RyZWFtOlxuICAgICAgICBpbmNsdWRlRG93bnN0cmVhbVN0YWNrcyhzZWxlY3RlZFN0YWNrcywgYWxsU3RhY2tzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uVXBzdHJlYW06XG4gICAgICAgIGluY2x1ZGVVcHN0cmVhbVN0YWNrcyhzZWxlY3RlZFN0YWNrcywgYWxsU3RhY2tzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIG9yaWdpbmFsIGFycmF5IGJlY2F1c2UgaXQgaXMgaW4gdGhlIHJpZ2h0IG9yZGVyXG4gICAgY29uc3Qgc2VsZWN0ZWRMaXN0ID0gc3RhY2tzLmZpbHRlcihzID0+IHNlbGVjdGVkU3RhY2tzLmhhcyhzLm5hbWUpKTtcblxuICAgIHJldHVybiBzZWxlY3RlZExpc3Q7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCBzdGFja3MgaW4gdGhlIENYXG4gICAqXG4gICAqIElmIHRoZSBzdGFja3MgaGF2ZSBkZXBlbmRlbmNpZXMgYmV0d2VlbiB0aGVtLCB0aGV5IHdpbGwgYmUgcmV0dXJuZWQgaW5cbiAgICogdG9wb2xvZ2ljYWxseSBzb3J0ZWQgb3JkZXIuIElmIHRoZXJlIGFyZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm90IGluIHRoZVxuICAgKiBzZXQsIHRoZXkgd2lsbCBiZSBpZ25vcmVkOyBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRoYXQgdGhlXG4gICAqIG5vbi1zZWxlY3RlZCBzdGFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gZGVwbG95ZWQgcHJldmlvdXNseS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0U3RhY2tzKCk6IFByb21pc2U8Y3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0W10+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3ludGhlc2l6ZVN0YWNrcygpO1xuICAgIHJldHVybiByZXNwb25zZS5zdGFja3M7XG4gIH1cblxuICAvKipcbiAgICogU3ludGhlc2l6ZSBhIHNpbmdsZSBzdGFja1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHN5bnRoZXNpemVTdGFjayhzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8Y3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PiB7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuc3ludGhlc2l6ZVN0YWNrcygpO1xuICAgIGNvbnN0IHN0YWNrID0gcmVzcC5nZXRTdGFjayhzdGFja05hbWUpO1xuICAgIHJldHVybiBzdGFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIGEgc2V0IG9mIHN0YWNrc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHN5bnRoZXNpemVTdGFja3MoKTogUHJvbWlzZTxjeGFwaS5DbG91ZEFzc2VtYmx5PiB7XG4gICAgaWYgKHRoaXMuYXNzZW1ibHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VtYmx5O1xuICAgIH1cblxuICAgIGNvbnN0IHRyYWNrVmVyc2lvbnM6IGJvb2xlYW4gPSB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsndmVyc2lvblJlcG9ydGluZyddKTtcblxuICAgIC8vIFdlIG1heSBuZWVkIHRvIHJ1biB0aGUgY2xvdWQgZXhlY3V0YWJsZSBtdWx0aXBsZSB0aW1lcyBpbiBvcmRlciB0byBzYXRpc2Z5IGFsbCBtaXNzaW5nIGNvbnRleHRcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCB0aGlzLnByb3BzLnN5bnRoZXNpemVyKHRoaXMucHJvcHMuYXdzLCB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBpZiAoYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZykge1xuICAgICAgICBkZWJ1ZyhgU29tZSBjb250ZXh0IGluZm9ybWF0aW9uIGlzIG1pc3NpbmcuIEZldGNoaW5nLi4uYCk7XG5cbiAgICAgICAgYXdhaXQgY29udGV4dHByb3ZpZGVycy5wcm92aWRlQ29udGV4dFZhbHVlcyhhc3NlbWJseS5tYW5pZmVzdC5taXNzaW5nLCB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uY29udGV4dCwgdGhpcy5wcm9wcy5hd3MpO1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSBuZXcgY29udGV4dCB0byBkaXNrXG4gICAgICAgIGF3YWl0IHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zYXZlQ29udGV4dCgpO1xuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2tWZXJzaW9ucyAmJiBhc3NlbWJseS5ydW50aW1lKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZXMgPSBmb3JtYXRNb2R1bGVzKGFzc2VtYmx5LnJ1bnRpbWUpO1xuICAgICAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIGFzc2VtYmx5LnN0YWNrcykge1xuICAgICAgICAgIGlmICghc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzb3VyY2VQcmVzZW50ID0gc3RhY2suZW52aXJvbm1lbnQucmVnaW9uID09PSBjeGFwaS5VTktOT1dOX1JFR0lPTlxuICAgICAgICAgICAgfHwgcmVnaW9uSW5mby5GYWN0LmZpbmQoc3RhY2suZW52aXJvbm1lbnQucmVnaW9uLCByZWdpb25JbmZvLkZhY3ROYW1lLkNES19NRVRBREFUQV9SRVNPVVJDRV9BVkFJTEFCTEUpID09PSAnWUVTJztcbiAgICAgICAgICBpZiAocmVzb3VyY2VQcmVzZW50KSB7XG4gICAgICAgICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YSkge1xuICAgICAgICAgICAgICBzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMuQ0RLTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgVHlwZTogJ0FXUzo6Q0RLOjpNZXRhZGF0YScsXG4gICAgICAgICAgICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgTW9kdWxlczogbW9kdWxlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm5pbmcoYFRoZSBzdGFjayAke3N0YWNrLm5hbWV9IGFscmVhZHkgaW5jbHVkZXMgYSBDREtNZXRhZGF0YSByZXNvdXJjZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbGwgZ29vZCwgcmV0dXJuXG4gICAgICB0aGlzLmFzc2VtYmx5ID0gYXNzZW1ibHk7XG4gICAgICByZXR1cm4gYXNzZW1ibHk7XG5cbiAgICAgIGZ1bmN0aW9uIGZvcm1hdE1vZHVsZXMocnVudGltZTogY3hhcGkuUnVudGltZUluZm8pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtb2R1bGVzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgICAgICAvLyBpbmplY3QgdG9vbGtpdCB2ZXJzaW9uIHRvIGxpc3Qgb2YgbW9kdWxlc1xuICAgICAgICBjb25zdCB0b29sa2l0VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4gICAgICAgIG1vZHVsZXMucHVzaChgYXdzLWNkaz0ke3Rvb2xraXRWZXJzaW9ufWApO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJ1bnRpbWUubGlicmFyaWVzKS5zb3J0KCkpIHtcbiAgICAgICAgICBtb2R1bGVzLnB1c2goYCR7a2V5fT0ke3J1bnRpbWUubGlicmFyaWVzW2tleV19YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZXMuam9pbignLCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSB0YWdzIGF2YWlsYWJsZSBpbiB0aGUgc3RhY2sgbWV0YWRhdGEuXG4gICAqL1xuICBwdWJsaWMgZ2V0VGFnc0Zyb21TdGFja01ldGFkYXRhKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QpOiBUYWdbXSB7XG4gICAgcmV0dXJuIGZsYXRNYXAoc3RhY2suZmluZE1ldGFkYXRhQnlUeXBlKGN4YXBpLlNUQUNLX1RBR1NfTUVUQURBVEFfS0VZKSwgeCA9PiB4LmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzICdhd3M6Y2RrOndhcm5pbmd8aW5mb3xlcnJvcicgbWV0YWRhdGEgZW50cmllcyBmcm9tIHRoZSBzdGFjayBzeW50aGVzaXNcbiAgICovXG4gIHB1YmxpYyBwcm9jZXNzTWV0YWRhdGEoc3RhY2tzOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXSkge1xuICAgIGxldCB3YXJuaW5ncyA9IGZhbHNlO1xuICAgIGxldCBlcnJvcnMgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2Ygc3RhY2subWVzc2FnZXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLmxldmVsKSB7XG4gICAgICAgICAgY2FzZSBjeGFwaS5TeW50aGVzaXNNZXNzYWdlTGV2ZWwuV0FSTklORzpcbiAgICAgICAgICAgIHdhcm5pbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucHJpbnRNZXNzYWdlKHdhcm5pbmcsICdXYXJuaW5nJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGN4YXBpLlN5bnRoZXNpc01lc3NhZ2VMZXZlbC5FUlJPUjpcbiAgICAgICAgICAgIGVycm9ycyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnByaW50TWVzc2FnZShlcnJvciwgJ0Vycm9yJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGN4YXBpLlN5bnRoZXNpc01lc3NhZ2VMZXZlbC5JTkZPOlxuICAgICAgICAgICAgdGhpcy5wcmludE1lc3NhZ2UocHJpbnQsICdJbmZvJywgbWVzc2FnZS5pZCwgbWVzc2FnZS5lbnRyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMgJiYgIXRoaXMucHJvcHMuaWdub3JlRXJyb3JzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGVycm9ycycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLnN0cmljdCAmJiB3YXJuaW5ncykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB3YXJuaW5ncyAoLS1zdHJpY3QgbW9kZSknKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByaW50TWVzc2FnZShsb2dGbjogKHM6IHN0cmluZykgPT4gdm9pZCwgcHJlZml4OiBzdHJpbmcsIGlkOiBzdHJpbmcsIGVudHJ5OiBjeGFwaS5NZXRhZGF0YUVudHJ5KSB7XG4gICAgbG9nRm4oYFske3ByZWZpeH0gYXQgJHtpZH1dICR7ZW50cnkuZGF0YX1gKTtcblxuICAgIGlmICh0aGlzLnByb3BzLnZlcmJvc2UgJiYgZW50cnkudHJhY2UpIHtcbiAgICAgIGxvZ0ZuKGAgICR7ZW50cnkudHJhY2Uuam9pbignXFxuICAnKX1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21iaW5lIHRoZSBuYW1lcyBvZiBhIHNldCBvZiBzdGFja3MgdXNpbmcgYSBjb21tYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdFN0YWNrTmFtZXMoc3RhY2tzOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXSk6IHN0cmluZyB7XG4gIHJldHVybiBzdGFja3MubWFwKHMgPT4gcy5uYW1lKS5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIFdoZW4gc2VsZWN0aW5nIHN0YWNrcywgd2hhdCBvdGhlciBzdGFja3MgdG8gaW5jbHVkZSBiZWNhdXNlIG9mIGRlcGVuZGVuY2llc1xuICovXG5leHBvcnQgZW51bSBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uIHtcbiAgLyoqXG4gICAqIERvbid0IHNlbGVjdCBhbnkgZXh0cmEgc3RhY2tzXG4gICAqL1xuICBOb25lLFxuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHN0YWNrcyB0aGF0IHRoaXMgc3RhY2sgZGVwZW5kcyBvblxuICAgKi9cbiAgVXBzdHJlYW0sXG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgc3RhY2tzIHRoYXQgZGVwZW5kIG9uIHRoaXMgc3RhY2tcbiAgICovXG4gIERvd25zdHJlYW1cbn1cblxuLyoqXG4gKiBJbmNsdWRlIHN0YWNrcyB0aGF0IGRlcGVuZCBvbiB0aGUgc3RhY2tzIGFscmVhZHkgaW4gdGhlIHNldFxuICpcbiAqIE1vZGlmaWVzIGBzZWxlY3RlZFN0YWNrc2AgaW4tcGxhY2UuXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVEb3duc3RyZWFtU3RhY2tzKFxuICAgIHNlbGVjdGVkU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+LFxuICAgIGFsbFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0Pikge1xuICBjb25zdCBhZGRlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgbGV0IG1hZGVQcm9ncmVzcyA9IHRydWU7XG4gIHdoaWxlIChtYWRlUHJvZ3Jlc3MpIHtcbiAgICBtYWRlUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgW25hbWUsIHN0YWNrXSBvZiBhbGxTdGFja3MpIHtcbiAgICAgIC8vIFNlbGVjdCB0aGlzIHN0YWNrIGlmIGl0J3Mgbm90IHNlbGVjdGVkIHlldCBBTkQgaXQgZGVwZW5kcyBvbiBhIHN0YWNrIHRoYXQncyBpbiB0aGUgc2VsZWN0ZWQgc2V0XG4gICAgICBpZiAoIXNlbGVjdGVkU3RhY2tzLmhhcyhuYW1lKSAmJiAoc3RhY2suZGVwZW5kZW5jaWVzIHx8IFtdKS5zb21lKGRlcCA9PiBzZWxlY3RlZFN0YWNrcy5oYXMoZGVwLmlkKSkpIHtcbiAgICAgICAgc2VsZWN0ZWRTdGFja3Muc2V0KG5hbWUsIHN0YWNrKTtcbiAgICAgICAgYWRkZWQucHVzaChuYW1lKTtcbiAgICAgICAgbWFkZVByb2dyZXNzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgIHByaW50KCdJbmNsdWRpbmcgZGVwZW5kaW5nIHN0YWNrczogJXMnLCBjb2xvcnMuYm9sZChhZGRlZC5qb2luKCcsICcpKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmNsdWRlIHN0YWNrcyB0aGF0IHRoYXQgc3RhY2tzIGluIHRoZSBzZXQgZGVwZW5kIG9uXG4gKlxuICogTW9kaWZpZXMgYHNlbGVjdGVkU3RhY2tzYCBpbi1wbGFjZS5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVVwc3RyZWFtU3RhY2tzKFxuICAgIHNlbGVjdGVkU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+LFxuICAgIGFsbFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0Pikge1xuICBjb25zdCBhZGRlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gIGxldCBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICB3aGlsZSAobWFkZVByb2dyZXNzKSB7XG4gICAgbWFkZVByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHNlbGVjdGVkU3RhY2tzLnZhbHVlcygpKSB7XG4gICAgICAvLyBTZWxlY3QgYW4gYWRkaXRpb25hbCBzdGFjayBpZiBpdCdzIG5vdCBzZWxlY3RlZCB5ZXQgYW5kIGEgZGVwZW5kZW5jeSBvZiBhIHNlbGVjdGVkIHN0YWNrIChhbmQgZXhpc3RzLCBvYnZpb3VzbHkpXG4gICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lOYW1lIG9mIHN0YWNrLmRlcGVuZGVuY2llcy5tYXAoeCA9PiB4LmlkKSkge1xuICAgICAgICBpZiAoIXNlbGVjdGVkU3RhY2tzLmhhcyhkZXBlbmRlbmN5TmFtZSkgJiYgYWxsU3RhY2tzLmhhcyhkZXBlbmRlbmN5TmFtZSkpIHtcbiAgICAgICAgICBhZGRlZC5wdXNoKGRlcGVuZGVuY3lOYW1lKTtcbiAgICAgICAgICBzZWxlY3RlZFN0YWNrcy5zZXQoZGVwZW5kZW5jeU5hbWUsIGFsbFN0YWNrcy5nZXQoZGVwZW5kZW5jeU5hbWUpISk7XG4gICAgICAgICAgbWFkZVByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgcHJpbnQoJ0luY2x1ZGluZyBkZXBlbmRlbmN5IHN0YWNrczogJXMnLCBjb2xvcnMuYm9sZChhZGRlZC5qb2luKCcsICcpKSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RlZFN0YWNrIGV4dGVuZHMgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0IHtcbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCBuYW1lIG9mIHRoZSBzdGFjayBiZWZvcmUgcmVuYW1pbmdcbiAgICovXG4gIG9yaWdpbmFsTmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhZyB7XG4gIHJlYWRvbmx5IEtleTogc3RyaW5nO1xuICByZWFkb25seSBWYWx1ZTogc3RyaW5nO1xufVxuIl19